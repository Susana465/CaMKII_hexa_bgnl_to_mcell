begin model

begin parameters
	# Default diffusion constants will require updating
	D_VOL 1e-6 # cm^2/s
	D_SURF 1e-8 # cm^2/s
	MCELL_DIFFUSION_CONSTANT_3D_Ca D_VOL
	MCELL_DIFFUSION_CONSTANT_3D_PP1 D_VOL
	MCELL_DIFFUSION_CONSTANT_3D_CaM D_VOL
	MCELL_DIFFUSION_CONSTANT_3D_CaMKII D_VOL
	MCELL_DIFFUSION_CONSTANT_2D_NMDAR D_SURF

	NA_um3 6.022e8 # Avogadro's number mutiplied by 1e-15 since we are using volume units of microns(^-3)
	VOL_RXN 1
	MCELL_REDEFINE_NA_um3 VOL_RXN # In MCell the units get multiplied by V_RXN so they stay the same

	# number of iterations for MCell
    ITERATIONS 3e3

	# Initial number of Ca molecules/cell
  	Ca_i 10000
	CaM_i 2000
	CaMKII_i 2000
	PP1_i 1000
	NMDAR_i 300

    # R1 to R4:  
 	kon_CaCaM 1e+6/NA_um3   # Bimolecular rate constant for CaM-Ca binding (1/# 1/s)
	koff_1Ca 1.928   # Unimolecular rate constant for CaM_Ca unbinding (1/s)
	koff_2Ca 1.937
	koff_3Ca 7.476
	koff_4Ca 25.783

	# 5.1 CaMKII + CaM_Ca4 < - > CaMKII_CaM_Ca4 (neeed to double check?)
	kon_cam_ca4_camkii 4.2e+6/NA_um3  
	koff_cam_ca4_camkii 2.5e-4

    # CaMKII flicker active/inactive (from pharris et al.,)
    kon_camkii_act 2e+4
	koff_camkii_inact 1e+7

	# CaMKII phosphorylation
	k_pCaM4 = 1e1/NA_um3 #0.96 #1/s #ref ordyan (1e5 in monomer model for susana's diss)
	k_pCaM4_P = 1e1/NA_um3 # added different phosphorylation rxn rate to avoid duplication warning when running bngl
	kon_T306_p 0.02 

	# Dephosphorylation ordyan
	# k_cat = (31/1.25)/60 # where do these numbers come from?
	# K_m = 11*(NA*V) #uM 

	k_dephos_camkii_p 2e1/NA_um3  # Pharris et al., number

	# CaMKII_active (and unbound to CaM) binding to NMDARs
	kon_CaMKII_NMDAR 3e5/NA_um3 #taken from 2nd_year PhD report
	koff_CaMKII_NMDAR 0.284

	# CaMKII_P (and unbound to CaM) binding to NMDARs
	kon_CaMKII_P_NMDAR 2e6/NA_um3 #taken from 2nd_year PhD report
	koff_CaMKII_P_NMDAR 0.03

	# Units: volumes in um3
	VolCP 0.50588 
	VolPM 0.0307 # from volume of 0.505 r = 0.494 and area = 3.07um2 * 0.01um thickness. Assuming a thickness of 0.01 microns for the PM
end parameters

begin compartments
 	PM 2 VolPM #2Dimensions, surface compartment
 	CP 3 VolCP PM #3Dimensions and 1 microcubic in volume, volume compartment
 	# http://www.lehman.edu/academics/cmacs/documents/RuleBasedPrimer-2011.pdf
end compartments

begin molecule types
  Ca()
  PP1()
  CaM(ca~0~1~2~3~4,camkii)
  CaMKII(active~0~1,T286~0~P,T306~0~P,cam,nmdar,l,r,c)
  NMDAR(camkii)
end molecule types

begin species
@CP:Ca() Ca_i
@CP:CaM(ca~0,camkii) CaM_i
# CaMKII dodecamer: CaMKII_i
@CP:CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!6,r!1,c!13).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!1,r!2,c!14).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!2,r!3,c!15).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!3,r!4,c!16).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!4,r!5,c!17).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!5,r!6,c!18).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!12,r!7,c!13).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!7,r!8,c!14).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!8,r!9,c!15).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!9,r!10,c!16).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!10,r!11,c!17).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!11,r!12,c!18) CaMKII_i

@CP:PP1() PP1_i
@PM:NMDAR(camkii) NMDAR_i
end species

begin reaction rules
# Ca binds to CaM progresively
#1  Ca + CaM < - > CaM_Ca1
	CaM(ca~0,camkii) + Ca() <-> CaM(ca~1,camkii) kon_CaCaM, koff_1Ca
#2  Ca + CaM_Ca1 < - > CaM_Ca2
 	CaM(ca~1,camkii) + Ca() <-> CaM(ca~2,camkii) kon_CaCaM, koff_2Ca
#3  Ca + CaM_Ca2 < - > CaM_Ca3
	CaM(ca~2,camkii) + Ca() <-> CaM(ca~3,camkii) kon_CaCaM, koff_3Ca
#4  Ca + CaM_Ca3 < - > CaM_Ca4
	CaM(ca~3,camkii) + Ca() <-> CaM(ca~4,camkii) kon_CaCaM, koff_4Ca

# CaMKII subunits can flicker between active or inactive. (CaM binds to active CaMKII only, "once arm and hand are open")
 	CaMKII(cam,T286~0,nmdar,active~0) <-> CaMKII(cam,T286~0,nmdar,active~1) kon_camkii_act, koff_camkii_inact

# 5.1 CaMKII + CaM_Ca4 < - > CaMKII_CaM 
# Saturated CaM_Ca4 binds to CaMKII ring, T306 needs to be unphosphorylated
# This reaction will only start happening after flickering of CaMKII to active state (next reaction) happens. This is because CaMKII released into the system is initially active~0.

	CaM(ca~4,camkii) + CaMKII(cam,T306~0,active~1) -> CaM(ca~4,camkii!1).CaMKII(cam!1,T306~0,active~1) kon_cam_ca4_camkii

# CaM rxn rate binding to phosphorylated CaMKII would be different than binding to CaMKII_P~0, do we need to specify this?

# CaM unbinding from either P or unP CaMKII, above CaM can bind to CaMKII no matter the T286 P state, requirement is that it's active and unP at T306.
# If T286~P, a subunit may remain active and phosphorylated even upon unbding of CaM
# Specification of active~1 is not necessary, because if bound to CaM is active anyway.
	CaMKII(T286~P,cam!2).CaM(ca~4,camkii!2) -> CaMKII(T286~P) + CaM(ca~4,camkii) koff_cam_camkiiP_TBD

# If T286~0, a subunit may remain active and unphosphorylated even upon unbding of CaM (i predict there wont be much of this? depening on rxn rate, but once camkii active, it prefers to be P?)
	CaMKII(T286~0,cam!2).CaM(ca~4,camkii!2) -> CaMKII(T286~0) + CaM(ca~4,camkii) koff_cam_camkiiP0_TBD

# CaMKII T286 phosphorylation 
# For the way this model is written, what is needed for T286 P is that CaMKII subunit and its neighbour are both active 
# (no matter if bound to cam or nmdar in terms of writing down reaction - rule based dcdw)
# If two neighbouring subunits are active, one may autoP the other at T286
	CaMKII(l!1,T286~0,active~1).CaMKII(r!1,active~1) -> CaMKII(l!1,T286~P,active~1).CaMKII(r!1,active~1) k_pCaM4 # what is the reaction rate?

# CaMKII T306 phosphorylation
# Note for future: this rxn is not necessary to have in the model as it's included in next reaction, but leaving for clarification.
# If CaMKII_P (at T286) and unbound to CaM, it may auto_phosphorylate at T306, blocking subsequent rebinding of CaM
#	CaMKII(cam,T286~P,T306~0,active~1) -> CaMKII(cam,T286~P,T306~P,active~1) kon_T306_p

# If CaMKII active (whether due to T286P or bound to NMDAR) and unbound to CaM, it may auto_phosphorylate at T306, blocking subsequent rebinding of CaM
	CaMKII(cam,T306~0,active~1) -> CaMKII(cam,T306~P,active~1) kon_T306_p

# CaM binding to CaMKII with unphosphorylated T306 prevents phosphorylation of this residue
# In other words, if CaMKII bound to CaM with t306~0, t306~p cannot happen. 

# CaMKII dephosphorylation. 
# The presence of CaM would structurally impede PP action, so cam binding site needs to be free for PP desphosphorylation.
# This means that CaM binding protects CaMKII_P state as PP1 cannot access it and dephospho otherwise.
	CaMKII(T286~P,cam) + PP1 -> CaMKII(T286~0,cam) + PP1 k_dephos_camkii_p_T286 
# CaMKII(T306~P, cam) not necessary to state cam unbound because cam will not be bound to camkii if T306P as stated in line 130
	CaMKII(T306~P) + PP1 -> CaMKII(T306~0) + PP1 k_dephos_camkii_p_T306 
# NMDAR/CaMKII binding
# CaMKII active can bind and unbind to NMDAR - cam binding site and nmdar binding site don't overlap so cam can be bound to camkii
	CaMKII(active~1,nmdar) + NMDAR(camkii) <-> CaMKII(active~1,nmdar!1).NMDAR(camkii!1) kon_CaMKII_NMDAR, koff_CaMKII_NMDAR

# what is needed is CaMKII to be active (not phosphorylated), only one subunit will be the requirement for this reaction. 
# CaMKII_P can bind and unbind to NMDAR ** q. does it matter if only one subunit is P, or should all subunits be P? how about active and P? look at notes from literature
	#CaMKII(T286~P,cam,nmdar) + NMDAR(camkii) <-> CaMKII(T286~P,cam,nmdar!1).NMDAR(camkii!1) kon_CaMKII_NMDAR, koff_CaMKII_NMDAR
	
end reaction rules

begin observables
  	Molecules CaM_free CaM(ca~0,camkii)
	Molecules CaM_Ca1 CaM(ca~1,camkii)
	Molecules CaM_Ca2 CaM(ca~2,camkii)
	Molecules CaM_Ca3 CaM(ca~3,camkii)
	Molecules CaM_Ca4 CaM(ca~4,camkii)
	Molecules CaMKII_CaM_Ca4 CaM(ca~4,camkii!1).CaMKII(cam!1,T286~0,nmdar,active~1)
	Species CaMKII CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!6,r!1,c!13).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!1,r!2,c!14).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!2,r!3,c!15).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!3,r!4,c!16).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!4,r!5,c!17).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!5,r!6,c!18).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!12,r!7,c!13).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!7,r!8,c!14).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!8,r!9,c!15).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!9,r!10,c!16).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!10,r!11,c!17).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!11,r!12,c!18)

	# Molecules CaMKII_inactive CaMKII(cam,T286~0,active~0)
	#Molecules CaMKII_ring_inactive CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!6,r!1,c).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!1,r!2,c).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!2,r!3,c).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!3,r!4,c).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!4,r!5,c).CaMKII(cam,nmdar,T286~0,T306~0,active~0,l!5,r!6,c)
    Molecules CaMKII_active CaMKII(T286~0,active~1)
	#Molecules CaMKII_ring_active CaMKII(active~1,l!6,r!1,c).CaMKII(active~1,l!1,r!2,c).CaMKII(active~1,l!2,r!3,c).CaMKII(active~1,l!3,r!4,c).CaMKII(active~1,l!4,r!5,c).CaMKII(active~1,l!5,r!6,c)
	#Molecules CaMKII_active_pairs CaMKII(T286~0,active~1).CaMKII(T286~0,active~1)
	Molecules CaMKII_P CaMKII(T286~P)

	Molecules NMDAR NMDAR(camkii)
	Molecules NMDAR_CaMKII CaMKII(active~1,cam,nmdar!1).NMDAR(camkii!1)
	Molecules NMDAR_CaMKII_P CaMKII(T286~P,cam,nmdar!1).NMDAR(camkii!1)
end observables


end model

generate_network({overwrite=>1}) #this command overwrites network everytime
#writeSBML()  
# Running for mcell:
simulate({method=>"ssa",t_start=>0,t_end=>"ITERATIONS",n_steps=>1000})
# Running only for bngl:
# left pp1 with 0, py file runs but only up to 0.01, why? ITERATIONS is what mcell reads
# not sure why: if I make ITERATIONS in python file to 100, it stops running at 30 iterations with 
# C:\mcell\rel\mcell\src4\count_buffer.cpp:94: MCell::CountBuffer::flush: Assertion `item.time == time && "Mismatch in gdat column times"' failed.
# simulate({method=>"ssa",t_end=>3,n_steps=>1e3}) 
