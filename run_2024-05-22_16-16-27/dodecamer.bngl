begin model

begin parameters
	# Default diffusion constants will require updating
	D_VOL 1e-6 # cm^2/s
	D_SURF 1e-8 # cm^2/s
	MCELL_DIFFUSION_CONSTANT_3D_Ca D_VOL
	MCELL_DIFFUSION_CONSTANT_3D_PP1 D_VOL
	MCELL_DIFFUSION_CONSTANT_3D_CaM D_VOL
	MCELL_DIFFUSION_CONSTANT_3D_CaMKII D_VOL
	MCELL_DIFFUSION_CONSTANT_2D_NMDAR D_SURF

	NA_um3 6.022e8 # Avogadro's number mutiplied by 1e-15 since we are using volume units of microns(^-3)
	VOL_RXN 1
	MCELL_REDEFINE_NA_um3 VOL_RXN # In MCell the units get multiplied by V_RXN so they stay the same

	# number of iterations for MCell
    ITERATIONS 3e3

	# Initial number of Ca molecules/cell
  	Ca_i 100000
	CaM_i 2000
	CaMKII_i 2000 
	PP1_i 1000
	NMDAR_i 300

    # R1 to R4:  
 	kon_CaCaM 1e+6/NA_um3   # Bimolecular rate constant for CaM-Ca binding (1/# 1/s)
	koff_1Ca 1.928   # Unimolecular rate constant for CaM_Ca unbinding (1/s)
	koff_2Ca 1.937
	koff_3Ca 7.476
	koff_4Ca 25.783

	# 5.1 CaMKII + CaM_Ca4 < - > CaMKII_CaM_Ca4
	kon_cam_ca4_camkii 4.2e+6/NA_um3  
	koff_cam_ca4_camkii 2.5e-4

    # CaMKII flicker active/inactive
    kon_camkii_act 2e+4
	koff_camkii_inact 1e+7

	# CaMKII phosphorylation
	k_pCaM4 = 5.7e8/NA_um3 #0.96 #1/s #ref ordyan (1e5 in monomer model for susana's diss)
	k_pCaM4_P = 1e6/NA_um3 # added different phosphorylation rxn rate to avoid duplication warning when running bngl

	# Dephosphorylation ordyan
	# k_cat = (31/1.25)/60 # where do these numbers come from?
	# K_m = 11*(NA*V) #uM 

	k_dephos_camkii_p 3e+3/NA_um3  # reaction number (8) on diss

	# CaMKII_active (and unbound to CaM) binding to NMDARs
	kon_CaMKII_NMDAR 3e5/NA_um3 #taken from 2nd_year PhD report
	koff_CaMKII_NMDAR 0.284

	# CaMKII_P (and unbound to CaM) binding to NMDARs
	kon_CaMKII_P_NMDAR 2e6/NA_um3 #taken from 2nd_year PhD report
	koff_CaMKII_P_NMDAR 0.03

	# Units: volumes in um3
	VolCP 0.50588 
	VolPM 0.0307 # from volume of 0.505 r = 0.494 and area = 3.07um2 * 0.01um thickness. Assuming a thickness of 0.01 microns for the PM
end parameters

begin compartments
 	PM 2 VolPM #2Dimensions, surface compartment
 	CP 3 VolCP PM #3Dimensions and 1 microcubic in volume, volume compartment
 	# http://www.lehman.edu/academics/cmacs/documents/RuleBasedPrimer-2011.pdf
end compartments

begin molecule types
  Ca()
  PP1()
  CaM(ca~0~1~2~3~4,camkii)
  CaMKII(active~0~1,T286~0~P,S306~0~P,cam,nmdar,l,r,c)
  NMDAR(camkii)
end molecule types

begin species
@CP:Ca() Ca_i
@CP:CaM(ca~0,camkii) CaM_i
# CaMKII dodecamer: CaMKII_i
@CP:CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!6,r!1,c!13).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!1,r!2,c!14).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!2,r!3,c!15).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!3,r!4,c!16).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!4,r!5,c!17).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!5,r!6,c!18).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!12,r!7,c!13).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!7,r!8,c!14).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!8,r!9,c!15).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!9,r!10,c!16).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!10,r!11,c!17).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!11,r!12,c!18) CaMKII_i

# CaMKII dodecamer as per Ordyan's model:
# CaMKII(active~0,r!1,l!6,c!13,T286~0,S306~0,nmdar,cam).CaMKII(active~0,r!2,l!1,c!14,T286~0,S306~0,nmdar,cam).\
# CaMKII(active~0,r!3,l!2,c!15,T286~0,S306~0,nmdar,cam).CaMKII(active~0,r!4,l!3,c!16,T286~0,S306~0,nmdar,cam).\
# CaMKII(active~0,r!5,l!4,c!17,T286~0,S306~0,nmdar,cam).CaMKII(active~0,r!6,l!5,c!18,T286~0,S306~0,nmdar,cam).\

# CaMKII(active~0,r!7,l!12,c!13,T286~0,S306~0,nmdar,cam).CaMKII(active~0,r!8,l!7,c!14,T286~0,S306~0,nmdar,cam).\
# CaMKII(active~0,r!9,l!8,c!15,T286~0,S306~0,nmdar,cam).CaMKII(active~0,r!10,l!9,c!16,T286~0,S306~0,nmdar,cam).\
# CaMKII(active~0,r!11,l!10,c!17,T286~0,S306~0,nmdar,cam).CaMKII(active~0,r!12,l!11,c!18,T286~0,S306~0,nmdar,cam) CaMKII_i
@CP:PP1() PP1_i
@PM:NMDAR(camkii) NMDAR_i
end species

begin reaction rules
# Ca binds to CaM progresively
#1  Ca + CaM < - > CaM_Ca1
	CaM(ca~0,camkii) + Ca() <-> CaM(ca~1,camkii) kon_CaCaM, koff_1Ca
#2  Ca + CaM_Ca1 < - > CaM_Ca2
 	CaM(ca~1,camkii) + Ca() <-> CaM(ca~2,camkii) kon_CaCaM, koff_2Ca
#3  Ca + CaM_Ca2 < - > CaM_Ca3
	CaM(ca~2,camkii) + Ca() <-> CaM(ca~3,camkii) kon_CaCaM, koff_3Ca
#4  Ca + CaM_Ca3 < - > CaM_Ca4
	CaM(ca~3,camkii) + Ca() <-> CaM(ca~4,camkii) kon_CaCaM, koff_4Ca

# Saturated CaM_Ca4 binds to CaMKII ring
# 5.1 CaMKII + CaM_Ca4 < - > CaMKII_CaM 
# This reaction will only start happening after flickering of CaMKII to active state (next reaction) happens. This is because CaMKII released into the system is initially active~0.
# ## DOCKED NEEDS TO BE ADDED OR NOT?
	CaM(ca~4,camkii) + CaMKII(cam,T286~0,nmdar,active~1) <-> CaM(ca~4,camkii!1).CaMKII(cam!1,T286~0,nmdar,active~1) kon_cam_ca4_camkii, koff_cam_ca4_camkii

# CaMKII subunits can flicker between active or inactive. (CaM binds to active CaMKII only)
 	CaMKII(cam,T286~0,nmdar,active~0) <-> CaMKII(cam,T286~0,nmdar,active~1) kon_camkii_act, koff_camkii_inact

# CaMKII phosphorylation
# When CaMKII_CaM, neighbouring subunit, if bound to CaM, can P
	CaMKII(l!1,T286~0,cam!2).CaM(ca~4,camkii!2).CaMKII(r!1,cam!+) -> CaMKII(l!1,T286~P,cam!2).CaM(ca~4,camkii!2).CaMKII(r!1,cam!+) k_pCaM4
# When CaMKII_CaM_P, can phosphorylate neighbouring subunit
  	CaMKII(l!1,T286~0,cam!2).CaM(ca~4,camkii!2).CaMKII(r!1,T286~P) -> CaMKII(l!1,T286~P,cam!2).CaM(ca~4,camkii!2).CaMKII(r!1,T286~P) k_pCaM4_P	

# CaMKII dephosphorylation
	CaMKII(T286~P) + PP1 -> CaMKII(T286~0) + PP1 k_dephos_camkii_p 

# CaMKII active can bind and unbind to NMDAR
	CaMKII(active~1,cam,nmdar) + NMDAR(camkii) <-> CaMKII(active~1,cam,nmdar!1).NMDAR(camkii!1) kon_CaMKII_NMDAR, koff_CaMKII_NMDAR

# CaMKII_P can bind and unbind to NMDAR ** q. does it matter if only one subunit is P, or should all subunits be P? how about active and P? look at notes from literature
	CaMKII(T286~P,cam,nmdar) + NMDAR(camkii) <-> CaMKII(T286~P,cam,nmdar!1).NMDAR(camkii!1) kon_CaMKII_NMDAR, koff_CaMKII_NMDAR
	
end reaction rules

begin observables
  	Molecules CaM_free CaM(ca~0,camkii)
	Molecules CaM_Ca1 CaM(ca~1,camkii)
	Molecules CaM_Ca2 CaM(ca~2,camkii)
	Molecules CaM_Ca3 CaM(ca~3,camkii)
	Molecules CaM_Ca4 CaM(ca~4,camkii)
	Molecules CaMKII_CaM_Ca4 CaM(ca~4,camkii!1).CaMKII(cam!1,T286~0,nmdar,active~1)
	Species CaMKII CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!6,r!1,c!13).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!1,r!2,c!14).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!2,r!3,c!15).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!3,r!4,c!16).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!4,r!5,c!17).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!5,r!6,c!18).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!12,r!7,c!13).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!7,r!8,c!14).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!8,r!9,c!15).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!9,r!10,c!16).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!10,r!11,c!17).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!11,r!12,c!18)

	# Molecules CaMKII_inactive CaMKII(cam,T286~0,active~0)
	#Molecules CaMKII_ring_inactive CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!6,r!1,c).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!1,r!2,c).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!2,r!3,c).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!3,r!4,c).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!4,r!5,c).CaMKII(cam,nmdar,T286~0,S306~0,active~0,l!5,r!6,c)
    Molecules CaMKII_active CaMKII(T286~0,active~1)
	#Molecules CaMKII_ring_active CaMKII(active~1,l!6,r!1,c).CaMKII(active~1,l!1,r!2,c).CaMKII(active~1,l!2,r!3,c).CaMKII(active~1,l!3,r!4,c).CaMKII(active~1,l!4,r!5,c).CaMKII(active~1,l!5,r!6,c)
	#Molecules CaMKII_active_pairs CaMKII(T286~0,active~1).CaMKII(T286~0,active~1)
	Molecules CaMKII_P CaMKII(T286~P)

	Molecules NMDAR NMDAR(camkii)
	Molecules NMDAR_CaMKII CaMKII(active~1,cam,nmdar!1).NMDAR(camkii!1)
	Molecules NMDAR_CaMKII_P CaMKII(T286~P,cam,nmdar!1).NMDAR(camkii!1)
end observables


end model

generate_network({overwrite=>1}) #this command overwrites network everytime
#writeSBML()  
# Running for mcell:
simulate({method=>"ssa",t_start=>0,t_end=>"ITERATIONS",n_steps=>1000})
# Running only for bngl:
# left pp1 with 0, py file runs but only up to 0.01, why? ITERATIONS is what mcell reads
# not sure why: if I make ITERATIONS in python file to 100, it stops running at 30 iterations with 
# C:\mcell\rel\mcell\src4\count_buffer.cpp:94: MCell::CountBuffer::flush: Assertion `item.time == time && "Mismatch in gdat column times"' failed.
# simulate({method=>"ssa",t_end=>3,n_steps=>1e3}) 
